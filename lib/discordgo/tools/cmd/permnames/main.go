package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strings"
	"text/template"
)

type perm struct{ IdentName, HumanName string }

var tmpl = template.Must(template.New("").Parse(`// Code generated by tools/cmd/permnames; DO NOT EDIT.
package discordgo

import "strconv"

func PermissionName(p int64) string {
	switch p {
	{{- range . }}
		case {{ .IdentName }}: return "{{ .HumanName }}"
	{{- end }}
	default:
		return "UnknownPermission(" + strconv.FormatInt(p, 10) + ")"
	}
}
`))

func main() {
	log.SetFlags(0)
	log.SetPrefix("permnames: ")

	fs := token.NewFileSet()
	parsedFile, err := parser.ParseFile(fs, "permission.go", nil, 0)
	if err != nil {
		log.Fatalln("could not parse permission.go:", err)
	}

	perms, err := extractPermData(parsedFile)
	if err != nil {
		log.Fatalln("could not extract permission data from file:", err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, perms)
	if err != nil {
		log.Fatalln("failed executing template:", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalln("failed formatting generated code:", err)
	}

	f, err := os.Create("permission_name.go")
	if err != nil {
		log.Fatalln("failed creating file:", err)
	}
	defer f.Close()

	if _, err := f.Write(formatted); err != nil {
		log.Fatalln("failed writing output file")
	}
}

func extractPermData(f *ast.File) ([]perm, error) {
	/*
		var AllPermissions = []int64{
			PermissionAdministrator,
			...,
		}
	*/
	expr, ok := findVarDecl(f, "AllPermissions")
	if !ok {
		return nil, errors.New("no declaration for var AllPermissions")
	}

	lit, ok := expr.(*ast.CompositeLit)
	if !ok {
		return nil, errors.New("type of AllPermissions is not array or slice")
	}

	var perms []perm
	for _, elt := range lit.Elts {
		ident, ok := elt.(*ast.Ident)
		if !ok {
			return nil, errors.New("non-identifier elements in declaration of var AllPermissions")
		}

		// identifier name is (say) PermissionManageMessages; human name is just
		// ManageMessages
		humanName, ok := strings.CutPrefix(ident.Name, "Permission")
		if !ok {
			return nil, fmt.Errorf("identifier %s does not start with 'Permission'", ident.Name)
		}
		perms = append(perms, perm{ident.Name, humanName})
	}

	return perms, nil
}

func findVarDecl(f *ast.File, name string) (ast.Expr, bool) {
	for _, decl := range f.Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok || decl.Tok != token.VAR {
			continue
		}

		for _, spec := range decl.Specs {
			spec, ok := spec.(*ast.ValueSpec)
			if !ok {
				continue
			}

			for i, ident := range spec.Names {
				if ident.Name == name {
					return spec.Values[i], true
				}
			}
		}
	}
	return nil, false
}
