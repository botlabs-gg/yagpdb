//go:build ignore

package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"net/http"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"unicode"
)

var (
	ConfusablesURI       = "https://www.unicode.org/Public/security/latest/confusables.txt"
	ExtraConfusablesFile = "./extraConfusables.json"
	UnicodeDataURI       = "https://www.unicode.org/Public/UNIDATA/UnicodeData.txt"

	FileHeader = `// This file was generated by go generate; DO NOT EDIT
package %s
`

	ParenRegex       = `\((.+)\)`
	ConfusablesRegex = `(?i)([a-zA-Z0-9 ]*) ;	([a-zA-Z0-9 ]*)+ ;	[a-z]{2,}	#\*? \( (.+) →(?: .+ →)* (.+) \) (?:.+)+ → (?:.+)`
	UnicodeDataRegex = `(?i)([a-z0-9]+);([^;]+);([a-z]+);[0-9]+;`
	LatinNameRegex   = `(?i)latin (small|capital) letter (.) (with .+)?`
)

var BasicLatin = &unicode.RangeTable{
	R16: []unicode.Range16{
		{0x0021, 0x007E, 1},
	},
	R32:         []unicode.Range32{},
	LatinOffset: 5,
}

// Takes a character name as input and then verifies if it's in the list of allowed characters.
func isAllowed(from, to string) bool {
	fromRune := []rune(from)
	toRune := []rune(to)

	if len(fromRune) > 1 {
		return false
	}

	for _, rn := range fromRune {
		if unicode.In(rn, BasicLatin) {
			return false
		}
	}
	for _, rn := range toRune {
		if !unicode.In(rn, BasicLatin) {
			return false
		}
	}

	return true
}

func formatUnicodeIDs(ids string) string {
	var formattedIDs string
	for _, charID := range strings.Split(ids, " ") {
		i, err := strconv.ParseInt(charID, 16, 32)
		if err != nil {
			fmt.Println(err)
			continue
		}

		c := rune(int32(i))

		formattedIDs += string(c)
	}

	return formattedIDs
}

// Used to sort the map to prevent massive diffs every generate.
type Pair struct {
	Key   string
	Value string
}

type PList []Pair

func (p PList) Len() int {
	return len(p)
}

func (p PList) Less(i, j int) bool {
	return p[i].Value < p[j].Value
}

func (p PList) Swap(i, j int) {
	p[i], p[j] = p[j], p[i]
}

// Replacer used by fixIssuesWithStr.
var mishapsReplacer = strings.NewReplacer(
	"vv", "w",
	"rn", "m",
)

// Fixes a lot of issues with the unicode specification, i.e. m -> rn.
func fixIssuesWithStr(str string) string {
	// Changes characters such as (16) into 16.
	parensRegex := regexp.MustCompile(ParenRegex)
	parensMatches := parensRegex.FindStringSubmatch(str)

	if len(parensMatches) >= 2 {
		str = parensMatches[1]
	}

	// Replace text according to mishapsReplacer.
	str = mishapsReplacer.Replace(str)

	return str
}

func makeMapping(charMap PList, varName string) string {
	mapping := fmt.Sprintf("var %s = []string{\n", varName)

	for _, character := range charMap {
		mapping += fmt.Sprintf("	%s,%s,\n", strconv.Quote(character.Key), strconv.Quote(character.Value))
	}

	mapping += "}"

	return mapping
}

func makeConfusables() {
	var confusables = make(map[string]string)

	confusablesRegex := regexp.MustCompile(ConfusablesRegex)

	// Add extra confusables as defined in extraConfusables.json.
	extraConfusables, err := os.OpenFile(ExtraConfusablesFile, os.O_RDWR|os.O_CREATE, 0755)
	if err != nil {
		fmt.Println(err)
		return
	}

	defer extraConfusables.Close()

	decoder := json.NewDecoder(extraConfusables)

	if err := decoder.Decode(&confusables); err != nil {
		fmt.Println(err)
	}

	// Fetch confusables from unicode.org.
	res, err := http.Get(ConfusablesURI)
	if err != nil {
		fmt.Println(err)
		return
	}

	defer res.Body.Close()

	scanner := bufio.NewScanner(res.Body)
	for scanner.Scan() {
		txt := scanner.Text()
		matches := confusablesRegex.FindStringSubmatch(txt)

		if len(matches) <= 0 {
			continue
		}

		// Checks if character is latin.
		if allowed := isAllowed(matches[3], matches[4]); !allowed {
			continue
		}

		// Converts unicode IDs into actual character.
		confusable := formatUnicodeIDs(matches[1])
		targettedCharacter := formatUnicodeIDs(matches[2])
		targettedCharacter = fixIssuesWithStr(targettedCharacter)

		if _, in := confusables[confusable]; in {
			continue
		}

		confusables[confusable] = targettedCharacter
	}

	if err := scanner.Err(); err != nil {
		fmt.Println(err)
		return
	}

	c := sortMap(confusables)

	fileContent := makeMapping(c, "confusables")

	WriteGoFile("confusables_table.go", "confusables", []byte(fileContent))
}

func makeDiacritics() {
	var diacritics = make(map[string]string)

	unicodeDataRegex := regexp.MustCompile(UnicodeDataRegex)
	latinCharacteRegex := regexp.MustCompile(LatinNameRegex)

	// Fetch Unicode Data from unicode.org.
	res, err := http.Get(UnicodeDataURI)
	if err != nil {
		fmt.Println(err)
		return
	}

	defer res.Body.Close()

	scanner := bufio.NewScanner(res.Body)
	for scanner.Scan() {
		txt := scanner.Text()

		unicodeMatches := unicodeDataRegex.FindStringSubmatch(txt)
		// Verify that the regex actually matched.
		if len(unicodeMatches) < 4 {
			continue
		}

		var diacritic string
		var replacement string

		if unicodeMatches[3] == "Mn" {
			diacritic = formatUnicodeIDs(unicodeMatches[1])
			replacement = ""
		}

		latinCharacterMatches := latinCharacteRegex.FindStringSubmatch(unicodeMatches[2])

		if len(latinCharacterMatches) == 4 {
			diacritic = formatUnicodeIDs(unicodeMatches[1])
			replacement = latinCharacterMatches[2]
		}

		// Change replaced character to lowercase if specified.
		if len(latinCharacterMatches) == 4 && latinCharacterMatches[1] == "SMALL" {
			replacement = strings.ToLower(replacement)
		}

		if len(diacritic) <= 0 {
			continue
		}

		diacritics[diacritic] = replacement
	}

	if err := scanner.Err(); err != nil {
		fmt.Println(err)
		return
	}

	c := sortMap(diacritics)

	fileContent := makeMapping(c, "diacritics")

	WriteGoFile("diacritic_table.go", "confusables", []byte(fileContent))
}

func main() {
	makeConfusables()
	makeDiacritics()
}

func sortMap(stringMap map[string]string) PList {
	c := make(PList, len(stringMap))

	i := 0
	for k, v := range stringMap {
		if len(k) <= 0 {
			continue
		}
		c[i] = Pair{k, v}
		i++
	}

	// Sort characters based off of rune int.
	sort.SliceStable(c, func(p, q int) bool {
		return []rune(c[p].Key)[0] < []rune(c[q].Key)[0]
	})

	return c
}

func WriteGoFile(filename, pkg string, b []byte) {
	w, err := os.Create(filename)
	if err != nil {
		log.Fatalf("Could not create file %s: %v", filename, err)
	}
	defer w.Close()

	_, err = fmt.Fprintf(w, FileHeader, pkg)
	if err != nil {
		log.Fatalf("Error writing header: %v", err)
	}

	// Strip leading newlines.
	for len(b) > 0 && b[0] == '\n' {
		b = b[1:]
	}
	formatted, err := format.Source(b)

	if err != nil {
		// Print the original buffer even in case of an error so that the
		// returned error can be meaningfully interpreted.
		w.Write(b)
		log.Fatalf("Error formatting file %s: %v", filename, err)
	}

	if _, err := w.Write(formatted); err != nil {
		log.Fatalf("Error writing file %s: %v", filename, err)
	}
}
