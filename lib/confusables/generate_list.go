//go:build ignore

package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
)

var (
	ConfusablesURI       = "https://www.unicode.org/Public/security/revision-06/confusables.txt"
	OutputFile           = "./confusables.json"
	ExtraConfusablesFile = "./extraConfusables.json"

	SmallLetters = make(map[string]string)
	BigLetters   = make(map[string]string)

	AllowedCharacters = []string{
		"SPACE",
		"LATIN %s LETTER A",
		"LATIN %s LETTER B",
		"LATIN %s LETTER C",
		"LATIN %s LETTER D",
		"LATIN %s LETTER E",
		"LATIN %s LETTER F",
		"LATIN %s LETTER G",
		"LATIN %s LETTER H",
		"LATIN %s LETTER I",
		"LATIN %s LETTER J",
		"LATIN %s LETTER K",
		"LATIN %s LETTER L",
		"LATIN %s LETTER M",
		"LATIN %s LETTER N",
		"LATIN %s LETTER O",
		"LATIN %s LETTER P",
		"LATIN %s LETTER Q",
		"LATIN %s LETTER R",
		"LATIN %s LETTER S",
		"LATIN %s LETTER T",
		"LATIN %s LETTER U",
		"LATIN %s LETTER V",
		"LATIN %s LETTER W",
		"LATIN %s LETTER X",
		"LATIN %s LETTER Y",
		"LATIN %s LETTER Z",
	}

	header = `// This file was generated by go generate; DO NOT EDIT
package %s
`
)

// Takes a character name as input and then verifies if it's in the list of allowed characters.
func isAllowed(characterName string) bool {
	for _, val := range AllowedCharacters {
		if characterName == val {
			return true
		}

		if characterName == fmt.Sprintf(val, "SMALL") {
			return true
		}

		if characterName == fmt.Sprintf(val, "CAPITAL") {
			return true
		}
	}

	return false
}

func main() {
	var confusables []string

	r := regexp.MustCompile(`(?i)[a-zA-Z0-9]* ;	(?:[a-zA-Z0-9]* )+;	[a-z]{2,}	#\*? \( (?P<sus>.+) →(?: .+ →)* (?P<unsus>.+) \) (?P<susname>.+)+ → (?P<unsusname>.+)	#`)

	file, err := os.OpenFile(OutputFile, os.O_RDWR|os.O_CREATE, 0755)
	if err != nil {
		fmt.Println(err)
		return
	}

	defer file.Close()

	// Reset file content
	file.WriteAt([]byte(""), 0)

	// Add extra confusables as defined in extraConfusables.json.
	extraConfusables, err := os.OpenFile(ExtraConfusablesFile, os.O_RDWR|os.O_CREATE, 0755)
	if err != nil {
		fmt.Println(err)
		return
	}

	defer extraConfusables.Close()

	decoder := json.NewDecoder(extraConfusables)

	if err := decoder.Decode(&confusables); err != nil {
		fmt.Println(err)
	}

	// Fetch confusables from unicode.org.
	res, err := http.Get(ConfusablesURI)
	if err != nil {
		fmt.Println(err)
		return
	}

	defer res.Body.Close()

	scanner := bufio.NewScanner(res.Body)
	for scanner.Scan() {
		txt := scanner.Text()
		matches := r.FindStringSubmatch(txt)

		if len(matches) <= 0 {
			continue
		}

		if allowed := isAllowed(matches[4]); !allowed {
			continue
		}

		confusables = append(confusables, matches[1], matches[2])
	}

	if err := scanner.Err(); err != nil {
		fmt.Println(err)
		return
	}

	fileContent := fmt.Sprintf("var confusables = []string{\"%s\"}", strings.Join(confusables, "\",\""))

	WriteGoFile("confusables_table.go", "confusables", []byte(fileContent))

	if err := json.NewEncoder(file).Encode(confusables); err != nil {
		fmt.Println(err)
	}
}

func WriteGoFile(filename, pkg string, b []byte) {
	w, err := os.Create(filename)
	if err != nil {
		log.Fatalf("Could not create file %s: %v", filename, err)
	}
	defer w.Close()

	_, err = fmt.Fprintf(w, header, pkg)
	if err != nil {
		log.Fatalf("Error writing header: %v", err)
	}

	// Strip leading newlines.
	for len(b) > 0 && b[0] == '\n' {
		b = b[1:]
	}
	formatted, err := format.Source(b)

	if err != nil {
		// Print the original buffer even in case of an error so that the
		// returned error can be meaningfully interpreted.
		w.Write(b)
		log.Fatalf("Error formatting file %s: %v", filename, err)
	}

	if _, err := w.Write(formatted); err != nil {
		log.Fatalf("Error writing file %s: %v", filename, err)
	}
}
