// Code generated by SQLBoiler 4.5.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// RoleMenu is an object representing the database table.
type RoleMenu struct {
	MessageID                     int64            `boil:"message_id" json:"message_id" toml:"message_id" yaml:"message_id"`
	GuildID                       int64            `boil:"guild_id" json:"guild_id" toml:"guild_id" yaml:"guild_id"`
	ChannelID                     int64            `boil:"channel_id" json:"channel_id" toml:"channel_id" yaml:"channel_id"`
	OwnerID                       int64            `boil:"owner_id" json:"owner_id" toml:"owner_id" yaml:"owner_id"`
	OwnMessage                    bool             `boil:"own_message" json:"own_message" toml:"own_message" yaml:"own_message"`
	State                         int64            `boil:"state" json:"state" toml:"state" yaml:"state"`
	NextRoleCommandID             null.Int64       `boil:"next_role_command_id" json:"next_role_command_id,omitempty" toml:"next_role_command_id" yaml:"next_role_command_id,omitempty"`
	RoleGroupID                   null.Int64       `boil:"role_group_id" json:"role_group_id,omitempty" toml:"role_group_id" yaml:"role_group_id,omitempty"`
	DisableSendDM                 bool             `boil:"disable_send_dm" json:"disable_send_dm" toml:"disable_send_dm" yaml:"disable_send_dm"`
	RemoveRoleOnReactionRemove    bool             `boil:"remove_role_on_reaction_remove" json:"remove_role_on_reaction_remove" toml:"remove_role_on_reaction_remove" yaml:"remove_role_on_reaction_remove"`
	FixedAmount                   bool             `boil:"fixed_amount" json:"fixed_amount" toml:"fixed_amount" yaml:"fixed_amount"`
	SkipAmount                    int              `boil:"skip_amount" json:"skip_amount" toml:"skip_amount" yaml:"skip_amount"`
	SetupMSGID                    int64            `boil:"setup_msg_id" json:"setup_msg_id" toml:"setup_msg_id" yaml:"setup_msg_id"`
	StandaloneMultipleMin         null.Int         `boil:"standalone_multiple_min" json:"standalone_multiple_min,omitempty" toml:"standalone_multiple_min" yaml:"standalone_multiple_min,omitempty"`
	StandaloneMultipleMax         null.Int         `boil:"standalone_multiple_max" json:"standalone_multiple_max,omitempty" toml:"standalone_multiple_max" yaml:"standalone_multiple_max,omitempty"`
	StandaloneSingleAutoToggleOff null.Bool        `boil:"standalone_single_auto_toggle_off" json:"standalone_single_auto_toggle_off,omitempty" toml:"standalone_single_auto_toggle_off" yaml:"standalone_single_auto_toggle_off,omitempty"`
	StandaloneSingleRequireOne    null.Bool        `boil:"standalone_single_require_one" json:"standalone_single_require_one,omitempty" toml:"standalone_single_require_one" yaml:"standalone_single_require_one,omitempty"`
	StandaloneBlacklistRoles      types.Int64Array `boil:"standalone_blacklist_roles" json:"standalone_blacklist_roles,omitempty" toml:"standalone_blacklist_roles" yaml:"standalone_blacklist_roles,omitempty"`
	StandaloneWhitelistRoles      types.Int64Array `boil:"standalone_whitelist_roles" json:"standalone_whitelist_roles,omitempty" toml:"standalone_whitelist_roles" yaml:"standalone_whitelist_roles,omitempty"`
	SavedContent                  null.String      `boil:"saved_content" json:"saved_content,omitempty" toml:"saved_content" yaml:"saved_content,omitempty"`
	SavedEmbed                    null.String      `boil:"saved_embed" json:"saved_embed,omitempty" toml:"saved_embed" yaml:"saved_embed,omitempty"`
	EditingOptionID               null.Int64       `boil:"editing_option_id" json:"editing_option_id,omitempty" toml:"editing_option_id" yaml:"editing_option_id,omitempty"`
	Kind                          int16            `boil:"kind" json:"kind" toml:"kind" yaml:"kind"`
	StandaloneMode                null.Int16       `boil:"standalone_mode" json:"standalone_mode,omitempty" toml:"standalone_mode" yaml:"standalone_mode,omitempty"`

	R *roleMenuR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L roleMenuL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var RoleMenuColumns = struct {
	MessageID                     string
	GuildID                       string
	ChannelID                     string
	OwnerID                       string
	OwnMessage                    string
	State                         string
	NextRoleCommandID             string
	RoleGroupID                   string
	DisableSendDM                 string
	RemoveRoleOnReactionRemove    string
	FixedAmount                   string
	SkipAmount                    string
	SetupMSGID                    string
	StandaloneMultipleMin         string
	StandaloneMultipleMax         string
	StandaloneSingleAutoToggleOff string
	StandaloneSingleRequireOne    string
	StandaloneBlacklistRoles      string
	StandaloneWhitelistRoles      string
	SavedContent                  string
	SavedEmbed                    string
	EditingOptionID               string
	Kind                          string
	StandaloneMode                string
}{
	MessageID:                     "message_id",
	GuildID:                       "guild_id",
	ChannelID:                     "channel_id",
	OwnerID:                       "owner_id",
	OwnMessage:                    "own_message",
	State:                         "state",
	NextRoleCommandID:             "next_role_command_id",
	RoleGroupID:                   "role_group_id",
	DisableSendDM:                 "disable_send_dm",
	RemoveRoleOnReactionRemove:    "remove_role_on_reaction_remove",
	FixedAmount:                   "fixed_amount",
	SkipAmount:                    "skip_amount",
	SetupMSGID:                    "setup_msg_id",
	StandaloneMultipleMin:         "standalone_multiple_min",
	StandaloneMultipleMax:         "standalone_multiple_max",
	StandaloneSingleAutoToggleOff: "standalone_single_auto_toggle_off",
	StandaloneSingleRequireOne:    "standalone_single_require_one",
	StandaloneBlacklistRoles:      "standalone_blacklist_roles",
	StandaloneWhitelistRoles:      "standalone_whitelist_roles",
	SavedContent:                  "saved_content",
	SavedEmbed:                    "saved_embed",
	EditingOptionID:               "editing_option_id",
	Kind:                          "kind",
	StandaloneMode:                "standalone_mode",
}

// Generated where

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelperint16 struct{ field string }

func (w whereHelperint16) EQ(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint16) NEQ(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint16) LT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint16) LTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint16) GT(x int16) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint16) GTE(x int16) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint16) IN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint16) NIN(slice []int16) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Int16 struct{ field string }

func (w whereHelpernull_Int16) EQ(x null.Int16) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int16) NEQ(x null.Int16) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int16) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int16) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }
func (w whereHelpernull_Int16) LT(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int16) LTE(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int16) GT(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int16) GTE(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

var RoleMenuWhere = struct {
	MessageID                     whereHelperint64
	GuildID                       whereHelperint64
	ChannelID                     whereHelperint64
	OwnerID                       whereHelperint64
	OwnMessage                    whereHelperbool
	State                         whereHelperint64
	NextRoleCommandID             whereHelpernull_Int64
	RoleGroupID                   whereHelpernull_Int64
	DisableSendDM                 whereHelperbool
	RemoveRoleOnReactionRemove    whereHelperbool
	FixedAmount                   whereHelperbool
	SkipAmount                    whereHelperint
	SetupMSGID                    whereHelperint64
	StandaloneMultipleMin         whereHelpernull_Int
	StandaloneMultipleMax         whereHelpernull_Int
	StandaloneSingleAutoToggleOff whereHelpernull_Bool
	StandaloneSingleRequireOne    whereHelpernull_Bool
	StandaloneBlacklistRoles      whereHelpertypes_Int64Array
	StandaloneWhitelistRoles      whereHelpertypes_Int64Array
	SavedContent                  whereHelpernull_String
	SavedEmbed                    whereHelpernull_String
	EditingOptionID               whereHelpernull_Int64
	Kind                          whereHelperint16
	StandaloneMode                whereHelpernull_Int16
}{
	MessageID:                     whereHelperint64{field: "\"role_menus\".\"message_id\""},
	GuildID:                       whereHelperint64{field: "\"role_menus\".\"guild_id\""},
	ChannelID:                     whereHelperint64{field: "\"role_menus\".\"channel_id\""},
	OwnerID:                       whereHelperint64{field: "\"role_menus\".\"owner_id\""},
	OwnMessage:                    whereHelperbool{field: "\"role_menus\".\"own_message\""},
	State:                         whereHelperint64{field: "\"role_menus\".\"state\""},
	NextRoleCommandID:             whereHelpernull_Int64{field: "\"role_menus\".\"next_role_command_id\""},
	RoleGroupID:                   whereHelpernull_Int64{field: "\"role_menus\".\"role_group_id\""},
	DisableSendDM:                 whereHelperbool{field: "\"role_menus\".\"disable_send_dm\""},
	RemoveRoleOnReactionRemove:    whereHelperbool{field: "\"role_menus\".\"remove_role_on_reaction_remove\""},
	FixedAmount:                   whereHelperbool{field: "\"role_menus\".\"fixed_amount\""},
	SkipAmount:                    whereHelperint{field: "\"role_menus\".\"skip_amount\""},
	SetupMSGID:                    whereHelperint64{field: "\"role_menus\".\"setup_msg_id\""},
	StandaloneMultipleMin:         whereHelpernull_Int{field: "\"role_menus\".\"standalone_multiple_min\""},
	StandaloneMultipleMax:         whereHelpernull_Int{field: "\"role_menus\".\"standalone_multiple_max\""},
	StandaloneSingleAutoToggleOff: whereHelpernull_Bool{field: "\"role_menus\".\"standalone_single_auto_toggle_off\""},
	StandaloneSingleRequireOne:    whereHelpernull_Bool{field: "\"role_menus\".\"standalone_single_require_one\""},
	StandaloneBlacklistRoles:      whereHelpertypes_Int64Array{field: "\"role_menus\".\"standalone_blacklist_roles\""},
	StandaloneWhitelistRoles:      whereHelpertypes_Int64Array{field: "\"role_menus\".\"standalone_whitelist_roles\""},
	SavedContent:                  whereHelpernull_String{field: "\"role_menus\".\"saved_content\""},
	SavedEmbed:                    whereHelpernull_String{field: "\"role_menus\".\"saved_embed\""},
	EditingOptionID:               whereHelpernull_Int64{field: "\"role_menus\".\"editing_option_id\""},
	Kind:                          whereHelperint16{field: "\"role_menus\".\"kind\""},
	StandaloneMode:                whereHelpernull_Int16{field: "\"role_menus\".\"standalone_mode\""},
}

// RoleMenuRels is where relationship names are stored.
var RoleMenuRels = struct {
	EditingOption   string
	NextRoleCommand string
	RoleGroup       string
	RoleMenuOptions string
}{
	EditingOption:   "EditingOption",
	NextRoleCommand: "NextRoleCommand",
	RoleGroup:       "RoleGroup",
	RoleMenuOptions: "RoleMenuOptions",
}

// roleMenuR is where relationships are stored.
type roleMenuR struct {
	EditingOption   *RoleMenuOption     `boil:"EditingOption" json:"EditingOption" toml:"EditingOption" yaml:"EditingOption"`
	NextRoleCommand *RoleCommand        `boil:"NextRoleCommand" json:"NextRoleCommand" toml:"NextRoleCommand" yaml:"NextRoleCommand"`
	RoleGroup       *RoleGroup          `boil:"RoleGroup" json:"RoleGroup" toml:"RoleGroup" yaml:"RoleGroup"`
	RoleMenuOptions RoleMenuOptionSlice `boil:"RoleMenuOptions" json:"RoleMenuOptions" toml:"RoleMenuOptions" yaml:"RoleMenuOptions"`
}

// NewStruct creates a new relationship struct
func (*roleMenuR) NewStruct() *roleMenuR {
	return &roleMenuR{}
}

// roleMenuL is where Load methods for each relationship are stored.
type roleMenuL struct{}

var (
	roleMenuAllColumns            = []string{"message_id", "guild_id", "channel_id", "owner_id", "own_message", "state", "next_role_command_id", "role_group_id", "disable_send_dm", "remove_role_on_reaction_remove", "fixed_amount", "skip_amount", "setup_msg_id", "standalone_multiple_min", "standalone_multiple_max", "standalone_single_auto_toggle_off", "standalone_single_require_one", "standalone_blacklist_roles", "standalone_whitelist_roles", "saved_content", "saved_embed", "editing_option_id", "kind", "standalone_mode"}
	roleMenuColumnsWithoutDefault = []string{"message_id", "guild_id", "channel_id", "owner_id", "own_message", "state", "next_role_command_id", "role_group_id", "standalone_multiple_min", "standalone_multiple_max", "standalone_single_auto_toggle_off", "standalone_single_require_one", "standalone_blacklist_roles", "standalone_whitelist_roles", "saved_content", "saved_embed", "editing_option_id", "standalone_mode"}
	roleMenuColumnsWithDefault    = []string{"disable_send_dm", "remove_role_on_reaction_remove", "fixed_amount", "skip_amount", "setup_msg_id", "kind"}
	roleMenuPrimaryKeyColumns     = []string{"message_id"}
)

type (
	// RoleMenuSlice is an alias for a slice of pointers to RoleMenu.
	// This should generally be used opposed to []RoleMenu.
	RoleMenuSlice []*RoleMenu

	roleMenuQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	roleMenuType                 = reflect.TypeOf(&RoleMenu{})
	roleMenuMapping              = queries.MakeStructMapping(roleMenuType)
	roleMenuPrimaryKeyMapping, _ = queries.BindMapping(roleMenuType, roleMenuMapping, roleMenuPrimaryKeyColumns)
	roleMenuInsertCacheMut       sync.RWMutex
	roleMenuInsertCache          = make(map[string]insertCache)
	roleMenuUpdateCacheMut       sync.RWMutex
	roleMenuUpdateCache          = make(map[string]updateCache)
	roleMenuUpsertCacheMut       sync.RWMutex
	roleMenuUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// OneG returns a single roleMenu record from the query using the global executor.
func (q roleMenuQuery) OneG(ctx context.Context) (*RoleMenu, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single roleMenu record from the query.
func (q roleMenuQuery) One(ctx context.Context, exec boil.ContextExecutor) (*RoleMenu, error) {
	o := &RoleMenu{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for role_menus")
	}

	return o, nil
}

// AllG returns all RoleMenu records from the query using the global executor.
func (q roleMenuQuery) AllG(ctx context.Context) (RoleMenuSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all RoleMenu records from the query.
func (q roleMenuQuery) All(ctx context.Context, exec boil.ContextExecutor) (RoleMenuSlice, error) {
	var o []*RoleMenu

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to RoleMenu slice")
	}

	return o, nil
}

// CountG returns the count of all RoleMenu records in the query, and panics on error.
func (q roleMenuQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all RoleMenu records in the query.
func (q roleMenuQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count role_menus rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table, and panics on error.
func (q roleMenuQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q roleMenuQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if role_menus exists")
	}

	return count > 0, nil
}

// EditingOption pointed to by the foreign key.
func (o *RoleMenu) EditingOption(mods ...qm.QueryMod) roleMenuOptionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.EditingOptionID),
	}

	queryMods = append(queryMods, mods...)

	query := RoleMenuOptions(queryMods...)
	queries.SetFrom(query.Query, "\"role_menu_options\"")

	return query
}

// NextRoleCommand pointed to by the foreign key.
func (o *RoleMenu) NextRoleCommand(mods ...qm.QueryMod) roleCommandQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.NextRoleCommandID),
	}

	queryMods = append(queryMods, mods...)

	query := RoleCommands(queryMods...)
	queries.SetFrom(query.Query, "\"role_commands\"")

	return query
}

// RoleGroup pointed to by the foreign key.
func (o *RoleMenu) RoleGroup(mods ...qm.QueryMod) roleGroupQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.RoleGroupID),
	}

	queryMods = append(queryMods, mods...)

	query := RoleGroups(queryMods...)
	queries.SetFrom(query.Query, "\"role_groups\"")

	return query
}

// RoleMenuOptions retrieves all the role_menu_option's RoleMenuOptions with an executor.
func (o *RoleMenu) RoleMenuOptions(mods ...qm.QueryMod) roleMenuOptionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"role_menu_options\".\"role_menu_id\"=?", o.MessageID),
	)

	query := RoleMenuOptions(queryMods...)
	queries.SetFrom(query.Query, "\"role_menu_options\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"role_menu_options\".*"})
	}

	return query
}

// LoadEditingOption allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (roleMenuL) LoadEditingOption(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRoleMenu interface{}, mods queries.Applicator) error {
	var slice []*RoleMenu
	var object *RoleMenu

	if singular {
		object = maybeRoleMenu.(*RoleMenu)
	} else {
		slice = *maybeRoleMenu.(*[]*RoleMenu)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &roleMenuR{}
		}
		if !queries.IsNil(object.EditingOptionID) {
			args = append(args, object.EditingOptionID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &roleMenuR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.EditingOptionID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.EditingOptionID) {
				args = append(args, obj.EditingOptionID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`role_menu_options`),
		qm.WhereIn(`role_menu_options.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load RoleMenuOption")
	}

	var resultSlice []*RoleMenuOption
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice RoleMenuOption")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for role_menu_options")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for role_menu_options")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.EditingOption = foreign
		if foreign.R == nil {
			foreign.R = &roleMenuOptionR{}
		}
		foreign.R.EditingOptionRoleMenus = append(foreign.R.EditingOptionRoleMenus, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.EditingOptionID, foreign.ID) {
				local.R.EditingOption = foreign
				if foreign.R == nil {
					foreign.R = &roleMenuOptionR{}
				}
				foreign.R.EditingOptionRoleMenus = append(foreign.R.EditingOptionRoleMenus, local)
				break
			}
		}
	}

	return nil
}

// LoadNextRoleCommand allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (roleMenuL) LoadNextRoleCommand(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRoleMenu interface{}, mods queries.Applicator) error {
	var slice []*RoleMenu
	var object *RoleMenu

	if singular {
		object = maybeRoleMenu.(*RoleMenu)
	} else {
		slice = *maybeRoleMenu.(*[]*RoleMenu)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &roleMenuR{}
		}
		if !queries.IsNil(object.NextRoleCommandID) {
			args = append(args, object.NextRoleCommandID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &roleMenuR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.NextRoleCommandID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.NextRoleCommandID) {
				args = append(args, obj.NextRoleCommandID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`role_commands`),
		qm.WhereIn(`role_commands.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load RoleCommand")
	}

	var resultSlice []*RoleCommand
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice RoleCommand")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for role_commands")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for role_commands")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.NextRoleCommand = foreign
		if foreign.R == nil {
			foreign.R = &roleCommandR{}
		}
		foreign.R.NextRoleCommandRoleMenus = append(foreign.R.NextRoleCommandRoleMenus, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.NextRoleCommandID, foreign.ID) {
				local.R.NextRoleCommand = foreign
				if foreign.R == nil {
					foreign.R = &roleCommandR{}
				}
				foreign.R.NextRoleCommandRoleMenus = append(foreign.R.NextRoleCommandRoleMenus, local)
				break
			}
		}
	}

	return nil
}

// LoadRoleGroup allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (roleMenuL) LoadRoleGroup(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRoleMenu interface{}, mods queries.Applicator) error {
	var slice []*RoleMenu
	var object *RoleMenu

	if singular {
		object = maybeRoleMenu.(*RoleMenu)
	} else {
		slice = *maybeRoleMenu.(*[]*RoleMenu)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &roleMenuR{}
		}
		if !queries.IsNil(object.RoleGroupID) {
			args = append(args, object.RoleGroupID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &roleMenuR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.RoleGroupID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.RoleGroupID) {
				args = append(args, obj.RoleGroupID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`role_groups`),
		qm.WhereIn(`role_groups.id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load RoleGroup")
	}

	var resultSlice []*RoleGroup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice RoleGroup")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for role_groups")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for role_groups")
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.RoleGroup = foreign
		if foreign.R == nil {
			foreign.R = &roleGroupR{}
		}
		foreign.R.RoleMenus = append(foreign.R.RoleMenus, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.RoleGroupID, foreign.ID) {
				local.R.RoleGroup = foreign
				if foreign.R == nil {
					foreign.R = &roleGroupR{}
				}
				foreign.R.RoleMenus = append(foreign.R.RoleMenus, local)
				break
			}
		}
	}

	return nil
}

// LoadRoleMenuOptions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (roleMenuL) LoadRoleMenuOptions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeRoleMenu interface{}, mods queries.Applicator) error {
	var slice []*RoleMenu
	var object *RoleMenu

	if singular {
		object = maybeRoleMenu.(*RoleMenu)
	} else {
		slice = *maybeRoleMenu.(*[]*RoleMenu)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &roleMenuR{}
		}
		args = append(args, object.MessageID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &roleMenuR{}
			}

			for _, a := range args {
				if a == obj.MessageID {
					continue Outer
				}
			}

			args = append(args, obj.MessageID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`role_menu_options`),
		qm.WhereIn(`role_menu_options.role_menu_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load role_menu_options")
	}

	var resultSlice []*RoleMenuOption
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice role_menu_options")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on role_menu_options")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for role_menu_options")
	}

	if singular {
		object.R.RoleMenuOptions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &roleMenuOptionR{}
			}
			foreign.R.RoleMenu = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.MessageID == foreign.RoleMenuID {
				local.R.RoleMenuOptions = append(local.R.RoleMenuOptions, foreign)
				if foreign.R == nil {
					foreign.R = &roleMenuOptionR{}
				}
				foreign.R.RoleMenu = local
				break
			}
		}
	}

	return nil
}

// SetEditingOptionG of the roleMenu to the related item.
// Sets o.R.EditingOption to related.
// Adds o to related.R.EditingOptionRoleMenus.
// Uses the global database handle.
func (o *RoleMenu) SetEditingOptionG(ctx context.Context, insert bool, related *RoleMenuOption) error {
	return o.SetEditingOption(ctx, boil.GetContextDB(), insert, related)
}

// SetEditingOption of the roleMenu to the related item.
// Sets o.R.EditingOption to related.
// Adds o to related.R.EditingOptionRoleMenus.
func (o *RoleMenu) SetEditingOption(ctx context.Context, exec boil.ContextExecutor, insert bool, related *RoleMenuOption) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"role_menus\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"editing_option_id"}),
		strmangle.WhereClause("\"", "\"", 2, roleMenuPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.MessageID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.EditingOptionID, related.ID)
	if o.R == nil {
		o.R = &roleMenuR{
			EditingOption: related,
		}
	} else {
		o.R.EditingOption = related
	}

	if related.R == nil {
		related.R = &roleMenuOptionR{
			EditingOptionRoleMenus: RoleMenuSlice{o},
		}
	} else {
		related.R.EditingOptionRoleMenus = append(related.R.EditingOptionRoleMenus, o)
	}

	return nil
}

// RemoveEditingOptionG relationship.
// Sets o.R.EditingOption to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *RoleMenu) RemoveEditingOptionG(ctx context.Context, related *RoleMenuOption) error {
	return o.RemoveEditingOption(ctx, boil.GetContextDB(), related)
}

// RemoveEditingOption relationship.
// Sets o.R.EditingOption to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *RoleMenu) RemoveEditingOption(ctx context.Context, exec boil.ContextExecutor, related *RoleMenuOption) error {
	var err error

	queries.SetScanner(&o.EditingOptionID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("editing_option_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.EditingOption = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.EditingOptionRoleMenus {
		if queries.Equal(o.EditingOptionID, ri.EditingOptionID) {
			continue
		}

		ln := len(related.R.EditingOptionRoleMenus)
		if ln > 1 && i < ln-1 {
			related.R.EditingOptionRoleMenus[i] = related.R.EditingOptionRoleMenus[ln-1]
		}
		related.R.EditingOptionRoleMenus = related.R.EditingOptionRoleMenus[:ln-1]
		break
	}
	return nil
}

// SetNextRoleCommandG of the roleMenu to the related item.
// Sets o.R.NextRoleCommand to related.
// Adds o to related.R.NextRoleCommandRoleMenus.
// Uses the global database handle.
func (o *RoleMenu) SetNextRoleCommandG(ctx context.Context, insert bool, related *RoleCommand) error {
	return o.SetNextRoleCommand(ctx, boil.GetContextDB(), insert, related)
}

// SetNextRoleCommand of the roleMenu to the related item.
// Sets o.R.NextRoleCommand to related.
// Adds o to related.R.NextRoleCommandRoleMenus.
func (o *RoleMenu) SetNextRoleCommand(ctx context.Context, exec boil.ContextExecutor, insert bool, related *RoleCommand) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"role_menus\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"next_role_command_id"}),
		strmangle.WhereClause("\"", "\"", 2, roleMenuPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.MessageID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.NextRoleCommandID, related.ID)
	if o.R == nil {
		o.R = &roleMenuR{
			NextRoleCommand: related,
		}
	} else {
		o.R.NextRoleCommand = related
	}

	if related.R == nil {
		related.R = &roleCommandR{
			NextRoleCommandRoleMenus: RoleMenuSlice{o},
		}
	} else {
		related.R.NextRoleCommandRoleMenus = append(related.R.NextRoleCommandRoleMenus, o)
	}

	return nil
}

// RemoveNextRoleCommandG relationship.
// Sets o.R.NextRoleCommand to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *RoleMenu) RemoveNextRoleCommandG(ctx context.Context, related *RoleCommand) error {
	return o.RemoveNextRoleCommand(ctx, boil.GetContextDB(), related)
}

// RemoveNextRoleCommand relationship.
// Sets o.R.NextRoleCommand to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *RoleMenu) RemoveNextRoleCommand(ctx context.Context, exec boil.ContextExecutor, related *RoleCommand) error {
	var err error

	queries.SetScanner(&o.NextRoleCommandID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("next_role_command_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.NextRoleCommand = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.NextRoleCommandRoleMenus {
		if queries.Equal(o.NextRoleCommandID, ri.NextRoleCommandID) {
			continue
		}

		ln := len(related.R.NextRoleCommandRoleMenus)
		if ln > 1 && i < ln-1 {
			related.R.NextRoleCommandRoleMenus[i] = related.R.NextRoleCommandRoleMenus[ln-1]
		}
		related.R.NextRoleCommandRoleMenus = related.R.NextRoleCommandRoleMenus[:ln-1]
		break
	}
	return nil
}

// SetRoleGroupG of the roleMenu to the related item.
// Sets o.R.RoleGroup to related.
// Adds o to related.R.RoleMenus.
// Uses the global database handle.
func (o *RoleMenu) SetRoleGroupG(ctx context.Context, insert bool, related *RoleGroup) error {
	return o.SetRoleGroup(ctx, boil.GetContextDB(), insert, related)
}

// SetRoleGroup of the roleMenu to the related item.
// Sets o.R.RoleGroup to related.
// Adds o to related.R.RoleMenus.
func (o *RoleMenu) SetRoleGroup(ctx context.Context, exec boil.ContextExecutor, insert bool, related *RoleGroup) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"role_menus\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"role_group_id"}),
		strmangle.WhereClause("\"", "\"", 2, roleMenuPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.MessageID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.RoleGroupID, related.ID)
	if o.R == nil {
		o.R = &roleMenuR{
			RoleGroup: related,
		}
	} else {
		o.R.RoleGroup = related
	}

	if related.R == nil {
		related.R = &roleGroupR{
			RoleMenus: RoleMenuSlice{o},
		}
	} else {
		related.R.RoleMenus = append(related.R.RoleMenus, o)
	}

	return nil
}

// RemoveRoleGroupG relationship.
// Sets o.R.RoleGroup to nil.
// Removes o from all passed in related items' relationships struct (Optional).
// Uses the global database handle.
func (o *RoleMenu) RemoveRoleGroupG(ctx context.Context, related *RoleGroup) error {
	return o.RemoveRoleGroup(ctx, boil.GetContextDB(), related)
}

// RemoveRoleGroup relationship.
// Sets o.R.RoleGroup to nil.
// Removes o from all passed in related items' relationships struct (Optional).
func (o *RoleMenu) RemoveRoleGroup(ctx context.Context, exec boil.ContextExecutor, related *RoleGroup) error {
	var err error

	queries.SetScanner(&o.RoleGroupID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("role_group_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.RoleGroup = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.RoleMenus {
		if queries.Equal(o.RoleGroupID, ri.RoleGroupID) {
			continue
		}

		ln := len(related.R.RoleMenus)
		if ln > 1 && i < ln-1 {
			related.R.RoleMenus[i] = related.R.RoleMenus[ln-1]
		}
		related.R.RoleMenus = related.R.RoleMenus[:ln-1]
		break
	}
	return nil
}

// AddRoleMenuOptionsG adds the given related objects to the existing relationships
// of the role_menu, optionally inserting them as new records.
// Appends related to o.R.RoleMenuOptions.
// Sets related.R.RoleMenu appropriately.
// Uses the global database handle.
func (o *RoleMenu) AddRoleMenuOptionsG(ctx context.Context, insert bool, related ...*RoleMenuOption) error {
	return o.AddRoleMenuOptions(ctx, boil.GetContextDB(), insert, related...)
}

// AddRoleMenuOptions adds the given related objects to the existing relationships
// of the role_menu, optionally inserting them as new records.
// Appends related to o.R.RoleMenuOptions.
// Sets related.R.RoleMenu appropriately.
func (o *RoleMenu) AddRoleMenuOptions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*RoleMenuOption) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.RoleMenuID = o.MessageID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"role_menu_options\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"role_menu_id"}),
				strmangle.WhereClause("\"", "\"", 2, roleMenuOptionPrimaryKeyColumns),
			)
			values := []interface{}{o.MessageID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.RoleMenuID = o.MessageID
		}
	}

	if o.R == nil {
		o.R = &roleMenuR{
			RoleMenuOptions: related,
		}
	} else {
		o.R.RoleMenuOptions = append(o.R.RoleMenuOptions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &roleMenuOptionR{
				RoleMenu: o,
			}
		} else {
			rel.R.RoleMenu = o
		}
	}
	return nil
}

// RoleMenus retrieves all the records using an executor.
func RoleMenus(mods ...qm.QueryMod) roleMenuQuery {
	mods = append(mods, qm.From("\"role_menus\""))
	return roleMenuQuery{NewQuery(mods...)}
}

// FindRoleMenuG retrieves a single record by ID.
func FindRoleMenuG(ctx context.Context, messageID int64, selectCols ...string) (*RoleMenu, error) {
	return FindRoleMenu(ctx, boil.GetContextDB(), messageID, selectCols...)
}

// FindRoleMenu retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindRoleMenu(ctx context.Context, exec boil.ContextExecutor, messageID int64, selectCols ...string) (*RoleMenu, error) {
	roleMenuObj := &RoleMenu{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"role_menus\" where \"message_id\"=$1", sel,
	)

	q := queries.Raw(query, messageID)

	err := q.Bind(ctx, exec, roleMenuObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from role_menus")
	}

	return roleMenuObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *RoleMenu) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *RoleMenu) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no role_menus provided for insertion")
	}

	var err error

	nzDefaults := queries.NonZeroDefaultSet(roleMenuColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	roleMenuInsertCacheMut.RLock()
	cache, cached := roleMenuInsertCache[key]
	roleMenuInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			roleMenuAllColumns,
			roleMenuColumnsWithDefault,
			roleMenuColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(roleMenuType, roleMenuMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(roleMenuType, roleMenuMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"role_menus\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"role_menus\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into role_menus")
	}

	if !cached {
		roleMenuInsertCacheMut.Lock()
		roleMenuInsertCache[key] = cache
		roleMenuInsertCacheMut.Unlock()
	}

	return nil
}

// UpdateG a single RoleMenu record using the global executor.
// See Update for more documentation.
func (o *RoleMenu) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the RoleMenu.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *RoleMenu) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	key := makeCacheKey(columns, nil)
	roleMenuUpdateCacheMut.RLock()
	cache, cached := roleMenuUpdateCache[key]
	roleMenuUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			roleMenuAllColumns,
			roleMenuPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update role_menus, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"role_menus\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, roleMenuPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(roleMenuType, roleMenuMapping, append(wl, roleMenuPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update role_menus row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for role_menus")
	}

	if !cached {
		roleMenuUpdateCacheMut.Lock()
		roleMenuUpdateCache[key] = cache
		roleMenuUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (q roleMenuQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q roleMenuQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for role_menus")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for role_menus")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o RoleMenuSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o RoleMenuSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), roleMenuPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"role_menus\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, roleMenuPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in roleMenu slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all roleMenu")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *RoleMenu) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *RoleMenu) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no role_menus provided for upsert")
	}

	nzDefaults := queries.NonZeroDefaultSet(roleMenuColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	roleMenuUpsertCacheMut.RLock()
	cache, cached := roleMenuUpsertCache[key]
	roleMenuUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			roleMenuAllColumns,
			roleMenuColumnsWithDefault,
			roleMenuColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			roleMenuAllColumns,
			roleMenuPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert role_menus, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(roleMenuPrimaryKeyColumns))
			copy(conflict, roleMenuPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"role_menus\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(roleMenuType, roleMenuMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(roleMenuType, roleMenuMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert role_menus")
	}

	if !cached {
		roleMenuUpsertCacheMut.Lock()
		roleMenuUpsertCache[key] = cache
		roleMenuUpsertCacheMut.Unlock()
	}

	return nil
}

// DeleteG deletes a single RoleMenu record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *RoleMenu) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single RoleMenu record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *RoleMenu) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no RoleMenu provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), roleMenuPrimaryKeyMapping)
	sql := "DELETE FROM \"role_menus\" WHERE \"message_id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from role_menus")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for role_menus")
	}

	return rowsAff, nil
}

func (q roleMenuQuery) DeleteAllG(ctx context.Context) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all matching rows.
func (q roleMenuQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no roleMenuQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from role_menus")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for role_menus")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o RoleMenuSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o RoleMenuSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), roleMenuPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"role_menus\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, roleMenuPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from roleMenu slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for role_menus")
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *RoleMenu) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: no RoleMenu provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *RoleMenu) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindRoleMenu(ctx, exec, o.MessageID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *RoleMenuSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: empty RoleMenuSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *RoleMenuSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := RoleMenuSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), roleMenuPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"role_menus\".* FROM \"role_menus\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, roleMenuPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in RoleMenuSlice")
	}

	*o = slice

	return nil
}

// RoleMenuExistsG checks if the RoleMenu row exists.
func RoleMenuExistsG(ctx context.Context, messageID int64) (bool, error) {
	return RoleMenuExists(ctx, boil.GetContextDB(), messageID)
}

// RoleMenuExists checks if the RoleMenu row exists.
func RoleMenuExists(ctx context.Context, exec boil.ContextExecutor, messageID int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"role_menus\" where \"message_id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, messageID)
	}
	row := exec.QueryRowContext(ctx, sql, messageID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if role_menus exists")
	}

	return exists, nil
}
