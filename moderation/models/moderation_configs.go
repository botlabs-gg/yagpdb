// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// ModerationConfig is an object representing the database table.
type ModerationConfig struct {
	GuildID                     int64            `boil:"guild_id" json:"guild_id" toml:"guild_id" yaml:"guild_id"`
	CreatedAt                   time.Time        `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt                   time.Time        `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	KickEnabled                 null.Bool        `boil:"kick_enabled" json:"kick_enabled,omitempty" toml:"kick_enabled" yaml:"kick_enabled,omitempty"`
	KickCmdRoles                types.Int64Array `boil:"kick_cmd_roles" json:"kick_cmd_roles,omitempty" toml:"kick_cmd_roles" yaml:"kick_cmd_roles,omitempty"`
	DeleteMessagesOnKick        null.Bool        `boil:"delete_messages_on_kick" json:"delete_messages_on_kick,omitempty" toml:"delete_messages_on_kick" yaml:"delete_messages_on_kick,omitempty"`
	KickReasonOptional          null.Bool        `boil:"kick_reason_optional" json:"kick_reason_optional,omitempty" toml:"kick_reason_optional" yaml:"kick_reason_optional,omitempty"`
	KickMessage                 null.String      `boil:"kick_message" json:"kick_message,omitempty" toml:"kick_message" yaml:"kick_message,omitempty"`
	BanEnabled                  null.Bool        `boil:"ban_enabled" json:"ban_enabled,omitempty" toml:"ban_enabled" yaml:"ban_enabled,omitempty"`
	BanCmdRoles                 types.Int64Array `boil:"ban_cmd_roles" json:"ban_cmd_roles,omitempty" toml:"ban_cmd_roles" yaml:"ban_cmd_roles,omitempty"`
	BanReasonOptional           null.Bool        `boil:"ban_reason_optional" json:"ban_reason_optional,omitempty" toml:"ban_reason_optional" yaml:"ban_reason_optional,omitempty"`
	BanMessage                  null.String      `boil:"ban_message" json:"ban_message,omitempty" toml:"ban_message" yaml:"ban_message,omitempty"`
	DefaultBanDeleteDays        null.Int64       `boil:"default_ban_delete_days" json:"default_ban_delete_days,omitempty" toml:"default_ban_delete_days" yaml:"default_ban_delete_days,omitempty"`
	TimeoutEnabled              null.Bool        `boil:"timeout_enabled" json:"timeout_enabled,omitempty" toml:"timeout_enabled" yaml:"timeout_enabled,omitempty"`
	TimeoutCmdRoles             types.Int64Array `boil:"timeout_cmd_roles" json:"timeout_cmd_roles,omitempty" toml:"timeout_cmd_roles" yaml:"timeout_cmd_roles,omitempty"`
	TimeoutReasonOptional       null.Bool        `boil:"timeout_reason_optional" json:"timeout_reason_optional,omitempty" toml:"timeout_reason_optional" yaml:"timeout_reason_optional,omitempty"`
	TimeoutRemoveReasonOptional null.Bool        `boil:"timeout_remove_reason_optional" json:"timeout_remove_reason_optional,omitempty" toml:"timeout_remove_reason_optional" yaml:"timeout_remove_reason_optional,omitempty"`
	TimeoutMessage              null.String      `boil:"timeout_message" json:"timeout_message,omitempty" toml:"timeout_message" yaml:"timeout_message,omitempty"`
	DefaultTimeoutDuration      null.Int64       `boil:"default_timeout_duration" json:"default_timeout_duration,omitempty" toml:"default_timeout_duration" yaml:"default_timeout_duration,omitempty"`
	MuteEnabled                 null.Bool        `boil:"mute_enabled" json:"mute_enabled,omitempty" toml:"mute_enabled" yaml:"mute_enabled,omitempty"`
	MuteCmdRoles                types.Int64Array `boil:"mute_cmd_roles" json:"mute_cmd_roles,omitempty" toml:"mute_cmd_roles" yaml:"mute_cmd_roles,omitempty"`
	MuteRole                    null.String      `boil:"mute_role" json:"mute_role,omitempty" toml:"mute_role" yaml:"mute_role,omitempty"`
	MuteDisallowReactionAdd     null.Bool        `boil:"mute_disallow_reaction_add" json:"mute_disallow_reaction_add,omitempty" toml:"mute_disallow_reaction_add" yaml:"mute_disallow_reaction_add,omitempty"`
	MuteReasonOptional          null.Bool        `boil:"mute_reason_optional" json:"mute_reason_optional,omitempty" toml:"mute_reason_optional" yaml:"mute_reason_optional,omitempty"`
	UnmuteReasonOptional        null.Bool        `boil:"unmute_reason_optional" json:"unmute_reason_optional,omitempty" toml:"unmute_reason_optional" yaml:"unmute_reason_optional,omitempty"`
	MuteManageRole              null.Bool        `boil:"mute_manage_role" json:"mute_manage_role,omitempty" toml:"mute_manage_role" yaml:"mute_manage_role,omitempty"`
	MuteRemoveRoles             types.Int64Array `boil:"mute_remove_roles" json:"mute_remove_roles,omitempty" toml:"mute_remove_roles" yaml:"mute_remove_roles,omitempty"`
	MuteIgnoreChannels          types.Int64Array `boil:"mute_ignore_channels" json:"mute_ignore_channels,omitempty" toml:"mute_ignore_channels" yaml:"mute_ignore_channels,omitempty"`
	MuteMessage                 null.String      `boil:"mute_message" json:"mute_message,omitempty" toml:"mute_message" yaml:"mute_message,omitempty"`
	UnmuteMessage               null.String      `boil:"unmute_message" json:"unmute_message,omitempty" toml:"unmute_message" yaml:"unmute_message,omitempty"`
	DefaultMuteDuration         null.Int64       `boil:"default_mute_duration" json:"default_mute_duration,omitempty" toml:"default_mute_duration" yaml:"default_mute_duration,omitempty"`
	WarnCommandsEnabled         null.Bool        `boil:"warn_commands_enabled" json:"warn_commands_enabled,omitempty" toml:"warn_commands_enabled" yaml:"warn_commands_enabled,omitempty"`
	WarnCmdRoles                types.Int64Array `boil:"warn_cmd_roles" json:"warn_cmd_roles,omitempty" toml:"warn_cmd_roles" yaml:"warn_cmd_roles,omitempty"`
	WarnIncludeChannelLogs      null.Bool        `boil:"warn_include_channel_logs" json:"warn_include_channel_logs,omitempty" toml:"warn_include_channel_logs" yaml:"warn_include_channel_logs,omitempty"`
	WarnSendToModlog            null.Bool        `boil:"warn_send_to_modlog" json:"warn_send_to_modlog,omitempty" toml:"warn_send_to_modlog" yaml:"warn_send_to_modlog,omitempty"`
	WarnMessage                 null.String      `boil:"warn_message" json:"warn_message,omitempty" toml:"warn_message" yaml:"warn_message,omitempty"`
	CleanEnabled                null.Bool        `boil:"clean_enabled" json:"clean_enabled,omitempty" toml:"clean_enabled" yaml:"clean_enabled,omitempty"`
	ReportEnabled               null.Bool        `boil:"report_enabled" json:"report_enabled,omitempty" toml:"report_enabled" yaml:"report_enabled,omitempty"`
	ActionChannel               null.String      `boil:"action_channel" json:"action_channel,omitempty" toml:"action_channel" yaml:"action_channel,omitempty"`
	ReportChannel               null.String      `boil:"report_channel" json:"report_channel,omitempty" toml:"report_channel" yaml:"report_channel,omitempty"`
	ErrorChannel                null.String      `boil:"error_channel" json:"error_channel,omitempty" toml:"error_channel" yaml:"error_channel,omitempty"`
	LogUnbans                   null.Bool        `boil:"log_unbans" json:"log_unbans,omitempty" toml:"log_unbans" yaml:"log_unbans,omitempty"`
	LogBans                     null.Bool        `boil:"log_bans" json:"log_bans,omitempty" toml:"log_bans" yaml:"log_bans,omitempty"`
	LogKicks                    null.Bool        `boil:"log_kicks" json:"log_kicks,omitempty" toml:"log_kicks" yaml:"log_kicks,omitempty"`
	LogTimeouts                 null.Bool        `boil:"log_timeouts" json:"log_timeouts,omitempty" toml:"log_timeouts" yaml:"log_timeouts,omitempty"`
	GiveRoleCmdEnabled          null.Bool        `boil:"give_role_cmd_enabled" json:"give_role_cmd_enabled,omitempty" toml:"give_role_cmd_enabled" yaml:"give_role_cmd_enabled,omitempty"`
	GiveRoleCmdModlog           null.Bool        `boil:"give_role_cmd_modlog" json:"give_role_cmd_modlog,omitempty" toml:"give_role_cmd_modlog" yaml:"give_role_cmd_modlog,omitempty"`
	GiveRoleCmdRoles            types.Int64Array `boil:"give_role_cmd_roles" json:"give_role_cmd_roles,omitempty" toml:"give_role_cmd_roles" yaml:"give_role_cmd_roles,omitempty"`

	R *moderationConfigR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L moderationConfigL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ModerationConfigColumns = struct {
	GuildID                     string
	CreatedAt                   string
	UpdatedAt                   string
	KickEnabled                 string
	KickCmdRoles                string
	DeleteMessagesOnKick        string
	KickReasonOptional          string
	KickMessage                 string
	BanEnabled                  string
	BanCmdRoles                 string
	BanReasonOptional           string
	BanMessage                  string
	DefaultBanDeleteDays        string
	TimeoutEnabled              string
	TimeoutCmdRoles             string
	TimeoutReasonOptional       string
	TimeoutRemoveReasonOptional string
	TimeoutMessage              string
	DefaultTimeoutDuration      string
	MuteEnabled                 string
	MuteCmdRoles                string
	MuteRole                    string
	MuteDisallowReactionAdd     string
	MuteReasonOptional          string
	UnmuteReasonOptional        string
	MuteManageRole              string
	MuteRemoveRoles             string
	MuteIgnoreChannels          string
	MuteMessage                 string
	UnmuteMessage               string
	DefaultMuteDuration         string
	WarnCommandsEnabled         string
	WarnCmdRoles                string
	WarnIncludeChannelLogs      string
	WarnSendToModlog            string
	WarnMessage                 string
	CleanEnabled                string
	ReportEnabled               string
	ActionChannel               string
	ReportChannel               string
	ErrorChannel                string
	LogUnbans                   string
	LogBans                     string
	LogKicks                    string
	LogTimeouts                 string
	GiveRoleCmdEnabled          string
	GiveRoleCmdModlog           string
	GiveRoleCmdRoles            string
}{
	GuildID:                     "guild_id",
	CreatedAt:                   "created_at",
	UpdatedAt:                   "updated_at",
	KickEnabled:                 "kick_enabled",
	KickCmdRoles:                "kick_cmd_roles",
	DeleteMessagesOnKick:        "delete_messages_on_kick",
	KickReasonOptional:          "kick_reason_optional",
	KickMessage:                 "kick_message",
	BanEnabled:                  "ban_enabled",
	BanCmdRoles:                 "ban_cmd_roles",
	BanReasonOptional:           "ban_reason_optional",
	BanMessage:                  "ban_message",
	DefaultBanDeleteDays:        "default_ban_delete_days",
	TimeoutEnabled:              "timeout_enabled",
	TimeoutCmdRoles:             "timeout_cmd_roles",
	TimeoutReasonOptional:       "timeout_reason_optional",
	TimeoutRemoveReasonOptional: "timeout_remove_reason_optional",
	TimeoutMessage:              "timeout_message",
	DefaultTimeoutDuration:      "default_timeout_duration",
	MuteEnabled:                 "mute_enabled",
	MuteCmdRoles:                "mute_cmd_roles",
	MuteRole:                    "mute_role",
	MuteDisallowReactionAdd:     "mute_disallow_reaction_add",
	MuteReasonOptional:          "mute_reason_optional",
	UnmuteReasonOptional:        "unmute_reason_optional",
	MuteManageRole:              "mute_manage_role",
	MuteRemoveRoles:             "mute_remove_roles",
	MuteIgnoreChannels:          "mute_ignore_channels",
	MuteMessage:                 "mute_message",
	UnmuteMessage:               "unmute_message",
	DefaultMuteDuration:         "default_mute_duration",
	WarnCommandsEnabled:         "warn_commands_enabled",
	WarnCmdRoles:                "warn_cmd_roles",
	WarnIncludeChannelLogs:      "warn_include_channel_logs",
	WarnSendToModlog:            "warn_send_to_modlog",
	WarnMessage:                 "warn_message",
	CleanEnabled:                "clean_enabled",
	ReportEnabled:               "report_enabled",
	ActionChannel:               "action_channel",
	ReportChannel:               "report_channel",
	ErrorChannel:                "error_channel",
	LogUnbans:                   "log_unbans",
	LogBans:                     "log_bans",
	LogKicks:                    "log_kicks",
	LogTimeouts:                 "log_timeouts",
	GiveRoleCmdEnabled:          "give_role_cmd_enabled",
	GiveRoleCmdModlog:           "give_role_cmd_modlog",
	GiveRoleCmdRoles:            "give_role_cmd_roles",
}

var ModerationConfigTableColumns = struct {
	GuildID                     string
	CreatedAt                   string
	UpdatedAt                   string
	KickEnabled                 string
	KickCmdRoles                string
	DeleteMessagesOnKick        string
	KickReasonOptional          string
	KickMessage                 string
	BanEnabled                  string
	BanCmdRoles                 string
	BanReasonOptional           string
	BanMessage                  string
	DefaultBanDeleteDays        string
	TimeoutEnabled              string
	TimeoutCmdRoles             string
	TimeoutReasonOptional       string
	TimeoutRemoveReasonOptional string
	TimeoutMessage              string
	DefaultTimeoutDuration      string
	MuteEnabled                 string
	MuteCmdRoles                string
	MuteRole                    string
	MuteDisallowReactionAdd     string
	MuteReasonOptional          string
	UnmuteReasonOptional        string
	MuteManageRole              string
	MuteRemoveRoles             string
	MuteIgnoreChannels          string
	MuteMessage                 string
	UnmuteMessage               string
	DefaultMuteDuration         string
	WarnCommandsEnabled         string
	WarnCmdRoles                string
	WarnIncludeChannelLogs      string
	WarnSendToModlog            string
	WarnMessage                 string
	CleanEnabled                string
	ReportEnabled               string
	ActionChannel               string
	ReportChannel               string
	ErrorChannel                string
	LogUnbans                   string
	LogBans                     string
	LogKicks                    string
	LogTimeouts                 string
	GiveRoleCmdEnabled          string
	GiveRoleCmdModlog           string
	GiveRoleCmdRoles            string
}{
	GuildID:                     "moderation_configs.guild_id",
	CreatedAt:                   "moderation_configs.created_at",
	UpdatedAt:                   "moderation_configs.updated_at",
	KickEnabled:                 "moderation_configs.kick_enabled",
	KickCmdRoles:                "moderation_configs.kick_cmd_roles",
	DeleteMessagesOnKick:        "moderation_configs.delete_messages_on_kick",
	KickReasonOptional:          "moderation_configs.kick_reason_optional",
	KickMessage:                 "moderation_configs.kick_message",
	BanEnabled:                  "moderation_configs.ban_enabled",
	BanCmdRoles:                 "moderation_configs.ban_cmd_roles",
	BanReasonOptional:           "moderation_configs.ban_reason_optional",
	BanMessage:                  "moderation_configs.ban_message",
	DefaultBanDeleteDays:        "moderation_configs.default_ban_delete_days",
	TimeoutEnabled:              "moderation_configs.timeout_enabled",
	TimeoutCmdRoles:             "moderation_configs.timeout_cmd_roles",
	TimeoutReasonOptional:       "moderation_configs.timeout_reason_optional",
	TimeoutRemoveReasonOptional: "moderation_configs.timeout_remove_reason_optional",
	TimeoutMessage:              "moderation_configs.timeout_message",
	DefaultTimeoutDuration:      "moderation_configs.default_timeout_duration",
	MuteEnabled:                 "moderation_configs.mute_enabled",
	MuteCmdRoles:                "moderation_configs.mute_cmd_roles",
	MuteRole:                    "moderation_configs.mute_role",
	MuteDisallowReactionAdd:     "moderation_configs.mute_disallow_reaction_add",
	MuteReasonOptional:          "moderation_configs.mute_reason_optional",
	UnmuteReasonOptional:        "moderation_configs.unmute_reason_optional",
	MuteManageRole:              "moderation_configs.mute_manage_role",
	MuteRemoveRoles:             "moderation_configs.mute_remove_roles",
	MuteIgnoreChannels:          "moderation_configs.mute_ignore_channels",
	MuteMessage:                 "moderation_configs.mute_message",
	UnmuteMessage:               "moderation_configs.unmute_message",
	DefaultMuteDuration:         "moderation_configs.default_mute_duration",
	WarnCommandsEnabled:         "moderation_configs.warn_commands_enabled",
	WarnCmdRoles:                "moderation_configs.warn_cmd_roles",
	WarnIncludeChannelLogs:      "moderation_configs.warn_include_channel_logs",
	WarnSendToModlog:            "moderation_configs.warn_send_to_modlog",
	WarnMessage:                 "moderation_configs.warn_message",
	CleanEnabled:                "moderation_configs.clean_enabled",
	ReportEnabled:               "moderation_configs.report_enabled",
	ActionChannel:               "moderation_configs.action_channel",
	ReportChannel:               "moderation_configs.report_channel",
	ErrorChannel:                "moderation_configs.error_channel",
	LogUnbans:                   "moderation_configs.log_unbans",
	LogBans:                     "moderation_configs.log_bans",
	LogKicks:                    "moderation_configs.log_kicks",
	LogTimeouts:                 "moderation_configs.log_timeouts",
	GiveRoleCmdEnabled:          "moderation_configs.give_role_cmd_enabled",
	GiveRoleCmdModlog:           "moderation_configs.give_role_cmd_modlog",
	GiveRoleCmdRoles:            "moderation_configs.give_role_cmd_roles",
}

// Generated where

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpertime_Time struct{ field string }

func (w whereHelpertime_Time) EQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.EQ, x)
}
func (w whereHelpertime_Time) NEQ(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.NEQ, x)
}
func (w whereHelpertime_Time) LT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertime_Time) LTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertime_Time) GT(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertime_Time) GTE(x time.Time) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

type whereHelpernull_Bool struct{ field string }

func (w whereHelpernull_Bool) EQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Bool) NEQ(x null.Bool) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Bool) LT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Bool) LTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Bool) GT(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Bool) GTE(x null.Bool) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Bool) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Bool) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpertypes_Int64Array struct{ field string }

func (w whereHelpertypes_Int64Array) EQ(x types.Int64Array) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_Int64Array) NEQ(x types.Int64Array) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_Int64Array) LT(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_Int64Array) LTE(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_Int64Array) GT(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_Int64Array) GTE(x types.Int64Array) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_Int64Array) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_Int64Array) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_String struct{ field string }

func (w whereHelpernull_String) EQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_String) NEQ(x null.String) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_String) LT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_String) LTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_String) GT(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_String) GTE(x null.String) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_String) LIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" LIKE ?", x)
}
func (w whereHelpernull_String) NLIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT LIKE ?", x)
}
func (w whereHelpernull_String) ILIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" ILIKE ?", x)
}
func (w whereHelpernull_String) NILIKE(x null.String) qm.QueryMod {
	return qm.Where(w.field+" NOT ILIKE ?", x)
}
func (w whereHelpernull_String) IN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_String) NIN(slice []string) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_String) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_String) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpernull_Int64 struct{ field string }

func (w whereHelpernull_Int64) EQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int64) NEQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int64) LT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int64) LTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int64) GT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int64) GTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var ModerationConfigWhere = struct {
	GuildID                     whereHelperint64
	CreatedAt                   whereHelpertime_Time
	UpdatedAt                   whereHelpertime_Time
	KickEnabled                 whereHelpernull_Bool
	KickCmdRoles                whereHelpertypes_Int64Array
	DeleteMessagesOnKick        whereHelpernull_Bool
	KickReasonOptional          whereHelpernull_Bool
	KickMessage                 whereHelpernull_String
	BanEnabled                  whereHelpernull_Bool
	BanCmdRoles                 whereHelpertypes_Int64Array
	BanReasonOptional           whereHelpernull_Bool
	BanMessage                  whereHelpernull_String
	DefaultBanDeleteDays        whereHelpernull_Int64
	TimeoutEnabled              whereHelpernull_Bool
	TimeoutCmdRoles             whereHelpertypes_Int64Array
	TimeoutReasonOptional       whereHelpernull_Bool
	TimeoutRemoveReasonOptional whereHelpernull_Bool
	TimeoutMessage              whereHelpernull_String
	DefaultTimeoutDuration      whereHelpernull_Int64
	MuteEnabled                 whereHelpernull_Bool
	MuteCmdRoles                whereHelpertypes_Int64Array
	MuteRole                    whereHelpernull_String
	MuteDisallowReactionAdd     whereHelpernull_Bool
	MuteReasonOptional          whereHelpernull_Bool
	UnmuteReasonOptional        whereHelpernull_Bool
	MuteManageRole              whereHelpernull_Bool
	MuteRemoveRoles             whereHelpertypes_Int64Array
	MuteIgnoreChannels          whereHelpertypes_Int64Array
	MuteMessage                 whereHelpernull_String
	UnmuteMessage               whereHelpernull_String
	DefaultMuteDuration         whereHelpernull_Int64
	WarnCommandsEnabled         whereHelpernull_Bool
	WarnCmdRoles                whereHelpertypes_Int64Array
	WarnIncludeChannelLogs      whereHelpernull_Bool
	WarnSendToModlog            whereHelpernull_Bool
	WarnMessage                 whereHelpernull_String
	CleanEnabled                whereHelpernull_Bool
	ReportEnabled               whereHelpernull_Bool
	ActionChannel               whereHelpernull_String
	ReportChannel               whereHelpernull_String
	ErrorChannel                whereHelpernull_String
	LogUnbans                   whereHelpernull_Bool
	LogBans                     whereHelpernull_Bool
	LogKicks                    whereHelpernull_Bool
	LogTimeouts                 whereHelpernull_Bool
	GiveRoleCmdEnabled          whereHelpernull_Bool
	GiveRoleCmdModlog           whereHelpernull_Bool
	GiveRoleCmdRoles            whereHelpertypes_Int64Array
}{
	GuildID:                     whereHelperint64{field: "\"moderation_configs\".\"guild_id\""},
	CreatedAt:                   whereHelpertime_Time{field: "\"moderation_configs\".\"created_at\""},
	UpdatedAt:                   whereHelpertime_Time{field: "\"moderation_configs\".\"updated_at\""},
	KickEnabled:                 whereHelpernull_Bool{field: "\"moderation_configs\".\"kick_enabled\""},
	KickCmdRoles:                whereHelpertypes_Int64Array{field: "\"moderation_configs\".\"kick_cmd_roles\""},
	DeleteMessagesOnKick:        whereHelpernull_Bool{field: "\"moderation_configs\".\"delete_messages_on_kick\""},
	KickReasonOptional:          whereHelpernull_Bool{field: "\"moderation_configs\".\"kick_reason_optional\""},
	KickMessage:                 whereHelpernull_String{field: "\"moderation_configs\".\"kick_message\""},
	BanEnabled:                  whereHelpernull_Bool{field: "\"moderation_configs\".\"ban_enabled\""},
	BanCmdRoles:                 whereHelpertypes_Int64Array{field: "\"moderation_configs\".\"ban_cmd_roles\""},
	BanReasonOptional:           whereHelpernull_Bool{field: "\"moderation_configs\".\"ban_reason_optional\""},
	BanMessage:                  whereHelpernull_String{field: "\"moderation_configs\".\"ban_message\""},
	DefaultBanDeleteDays:        whereHelpernull_Int64{field: "\"moderation_configs\".\"default_ban_delete_days\""},
	TimeoutEnabled:              whereHelpernull_Bool{field: "\"moderation_configs\".\"timeout_enabled\""},
	TimeoutCmdRoles:             whereHelpertypes_Int64Array{field: "\"moderation_configs\".\"timeout_cmd_roles\""},
	TimeoutReasonOptional:       whereHelpernull_Bool{field: "\"moderation_configs\".\"timeout_reason_optional\""},
	TimeoutRemoveReasonOptional: whereHelpernull_Bool{field: "\"moderation_configs\".\"timeout_remove_reason_optional\""},
	TimeoutMessage:              whereHelpernull_String{field: "\"moderation_configs\".\"timeout_message\""},
	DefaultTimeoutDuration:      whereHelpernull_Int64{field: "\"moderation_configs\".\"default_timeout_duration\""},
	MuteEnabled:                 whereHelpernull_Bool{field: "\"moderation_configs\".\"mute_enabled\""},
	MuteCmdRoles:                whereHelpertypes_Int64Array{field: "\"moderation_configs\".\"mute_cmd_roles\""},
	MuteRole:                    whereHelpernull_String{field: "\"moderation_configs\".\"mute_role\""},
	MuteDisallowReactionAdd:     whereHelpernull_Bool{field: "\"moderation_configs\".\"mute_disallow_reaction_add\""},
	MuteReasonOptional:          whereHelpernull_Bool{field: "\"moderation_configs\".\"mute_reason_optional\""},
	UnmuteReasonOptional:        whereHelpernull_Bool{field: "\"moderation_configs\".\"unmute_reason_optional\""},
	MuteManageRole:              whereHelpernull_Bool{field: "\"moderation_configs\".\"mute_manage_role\""},
	MuteRemoveRoles:             whereHelpertypes_Int64Array{field: "\"moderation_configs\".\"mute_remove_roles\""},
	MuteIgnoreChannels:          whereHelpertypes_Int64Array{field: "\"moderation_configs\".\"mute_ignore_channels\""},
	MuteMessage:                 whereHelpernull_String{field: "\"moderation_configs\".\"mute_message\""},
	UnmuteMessage:               whereHelpernull_String{field: "\"moderation_configs\".\"unmute_message\""},
	DefaultMuteDuration:         whereHelpernull_Int64{field: "\"moderation_configs\".\"default_mute_duration\""},
	WarnCommandsEnabled:         whereHelpernull_Bool{field: "\"moderation_configs\".\"warn_commands_enabled\""},
	WarnCmdRoles:                whereHelpertypes_Int64Array{field: "\"moderation_configs\".\"warn_cmd_roles\""},
	WarnIncludeChannelLogs:      whereHelpernull_Bool{field: "\"moderation_configs\".\"warn_include_channel_logs\""},
	WarnSendToModlog:            whereHelpernull_Bool{field: "\"moderation_configs\".\"warn_send_to_modlog\""},
	WarnMessage:                 whereHelpernull_String{field: "\"moderation_configs\".\"warn_message\""},
	CleanEnabled:                whereHelpernull_Bool{field: "\"moderation_configs\".\"clean_enabled\""},
	ReportEnabled:               whereHelpernull_Bool{field: "\"moderation_configs\".\"report_enabled\""},
	ActionChannel:               whereHelpernull_String{field: "\"moderation_configs\".\"action_channel\""},
	ReportChannel:               whereHelpernull_String{field: "\"moderation_configs\".\"report_channel\""},
	ErrorChannel:                whereHelpernull_String{field: "\"moderation_configs\".\"error_channel\""},
	LogUnbans:                   whereHelpernull_Bool{field: "\"moderation_configs\".\"log_unbans\""},
	LogBans:                     whereHelpernull_Bool{field: "\"moderation_configs\".\"log_bans\""},
	LogKicks:                    whereHelpernull_Bool{field: "\"moderation_configs\".\"log_kicks\""},
	LogTimeouts:                 whereHelpernull_Bool{field: "\"moderation_configs\".\"log_timeouts\""},
	GiveRoleCmdEnabled:          whereHelpernull_Bool{field: "\"moderation_configs\".\"give_role_cmd_enabled\""},
	GiveRoleCmdModlog:           whereHelpernull_Bool{field: "\"moderation_configs\".\"give_role_cmd_modlog\""},
	GiveRoleCmdRoles:            whereHelpertypes_Int64Array{field: "\"moderation_configs\".\"give_role_cmd_roles\""},
}

// ModerationConfigRels is where relationship names are stored.
var ModerationConfigRels = struct {
}{}

// moderationConfigR is where relationships are stored.
type moderationConfigR struct {
}

// NewStruct creates a new relationship struct
func (*moderationConfigR) NewStruct() *moderationConfigR {
	return &moderationConfigR{}
}

// moderationConfigL is where Load methods for each relationship are stored.
type moderationConfigL struct{}

var (
	moderationConfigAllColumns            = []string{"guild_id", "created_at", "updated_at", "kick_enabled", "kick_cmd_roles", "delete_messages_on_kick", "kick_reason_optional", "kick_message", "ban_enabled", "ban_cmd_roles", "ban_reason_optional", "ban_message", "default_ban_delete_days", "timeout_enabled", "timeout_cmd_roles", "timeout_reason_optional", "timeout_remove_reason_optional", "timeout_message", "default_timeout_duration", "mute_enabled", "mute_cmd_roles", "mute_role", "mute_disallow_reaction_add", "mute_reason_optional", "unmute_reason_optional", "mute_manage_role", "mute_remove_roles", "mute_ignore_channels", "mute_message", "unmute_message", "default_mute_duration", "warn_commands_enabled", "warn_cmd_roles", "warn_include_channel_logs", "warn_send_to_modlog", "warn_message", "clean_enabled", "report_enabled", "action_channel", "report_channel", "error_channel", "log_unbans", "log_bans", "log_kicks", "log_timeouts", "give_role_cmd_enabled", "give_role_cmd_modlog", "give_role_cmd_roles"}
	moderationConfigColumnsWithoutDefault = []string{"guild_id", "created_at", "updated_at"}
	moderationConfigColumnsWithDefault    = []string{"kick_enabled", "kick_cmd_roles", "delete_messages_on_kick", "kick_reason_optional", "kick_message", "ban_enabled", "ban_cmd_roles", "ban_reason_optional", "ban_message", "default_ban_delete_days", "timeout_enabled", "timeout_cmd_roles", "timeout_reason_optional", "timeout_remove_reason_optional", "timeout_message", "default_timeout_duration", "mute_enabled", "mute_cmd_roles", "mute_role", "mute_disallow_reaction_add", "mute_reason_optional", "unmute_reason_optional", "mute_manage_role", "mute_remove_roles", "mute_ignore_channels", "mute_message", "unmute_message", "default_mute_duration", "warn_commands_enabled", "warn_cmd_roles", "warn_include_channel_logs", "warn_send_to_modlog", "warn_message", "clean_enabled", "report_enabled", "action_channel", "report_channel", "error_channel", "log_unbans", "log_bans", "log_kicks", "log_timeouts", "give_role_cmd_enabled", "give_role_cmd_modlog", "give_role_cmd_roles"}
	moderationConfigPrimaryKeyColumns     = []string{"guild_id"}
	moderationConfigGeneratedColumns      = []string{}
)

type (
	// ModerationConfigSlice is an alias for a slice of pointers to ModerationConfig.
	// This should almost always be used instead of []ModerationConfig.
	ModerationConfigSlice []*ModerationConfig

	moderationConfigQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	moderationConfigType                 = reflect.TypeOf(&ModerationConfig{})
	moderationConfigMapping              = queries.MakeStructMapping(moderationConfigType)
	moderationConfigPrimaryKeyMapping, _ = queries.BindMapping(moderationConfigType, moderationConfigMapping, moderationConfigPrimaryKeyColumns)
	moderationConfigInsertCacheMut       sync.RWMutex
	moderationConfigInsertCache          = make(map[string]insertCache)
	moderationConfigUpdateCacheMut       sync.RWMutex
	moderationConfigUpdateCache          = make(map[string]updateCache)
	moderationConfigUpsertCacheMut       sync.RWMutex
	moderationConfigUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

// OneG returns a single moderationConfig record from the query using the global executor.
func (q moderationConfigQuery) OneG(ctx context.Context) (*ModerationConfig, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single moderationConfig record from the query.
func (q moderationConfigQuery) One(ctx context.Context, exec boil.ContextExecutor) (*ModerationConfig, error) {
	o := &ModerationConfig{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for moderation_configs")
	}

	return o, nil
}

// AllG returns all ModerationConfig records from the query using the global executor.
func (q moderationConfigQuery) AllG(ctx context.Context) (ModerationConfigSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all ModerationConfig records from the query.
func (q moderationConfigQuery) All(ctx context.Context, exec boil.ContextExecutor) (ModerationConfigSlice, error) {
	var o []*ModerationConfig

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to ModerationConfig slice")
	}

	return o, nil
}

// CountG returns the count of all ModerationConfig records in the query using the global executor
func (q moderationConfigQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all ModerationConfig records in the query.
func (q moderationConfigQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count moderation_configs rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q moderationConfigQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q moderationConfigQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if moderation_configs exists")
	}

	return count > 0, nil
}

// ModerationConfigs retrieves all the records using an executor.
func ModerationConfigs(mods ...qm.QueryMod) moderationConfigQuery {
	mods = append(mods, qm.From("\"moderation_configs\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"moderation_configs\".*"})
	}

	return moderationConfigQuery{q}
}

// FindModerationConfigG retrieves a single record by ID.
func FindModerationConfigG(ctx context.Context, guildID int64, selectCols ...string) (*ModerationConfig, error) {
	return FindModerationConfig(ctx, boil.GetContextDB(), guildID, selectCols...)
}

// FindModerationConfig retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindModerationConfig(ctx context.Context, exec boil.ContextExecutor, guildID int64, selectCols ...string) (*ModerationConfig, error) {
	moderationConfigObj := &ModerationConfig{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"moderation_configs\" where \"guild_id\"=$1", sel,
	)

	q := queries.Raw(query, guildID)

	err := q.Bind(ctx, exec, moderationConfigObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from moderation_configs")
	}

	return moderationConfigObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *ModerationConfig) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *ModerationConfig) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no moderation_configs provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	nzDefaults := queries.NonZeroDefaultSet(moderationConfigColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	moderationConfigInsertCacheMut.RLock()
	cache, cached := moderationConfigInsertCache[key]
	moderationConfigInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			moderationConfigAllColumns,
			moderationConfigColumnsWithDefault,
			moderationConfigColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(moderationConfigType, moderationConfigMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(moderationConfigType, moderationConfigMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"moderation_configs\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"moderation_configs\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into moderation_configs")
	}

	if !cached {
		moderationConfigInsertCacheMut.Lock()
		moderationConfigInsertCache[key] = cache
		moderationConfigInsertCacheMut.Unlock()
	}

	return nil
}

// UpdateG a single ModerationConfig record using the global executor.
// See Update for more documentation.
func (o *ModerationConfig) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the ModerationConfig.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *ModerationConfig) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	key := makeCacheKey(columns, nil)
	moderationConfigUpdateCacheMut.RLock()
	cache, cached := moderationConfigUpdateCache[key]
	moderationConfigUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			moderationConfigAllColumns,
			moderationConfigPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update moderation_configs, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"moderation_configs\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, moderationConfigPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(moderationConfigType, moderationConfigMapping, append(wl, moderationConfigPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update moderation_configs row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for moderation_configs")
	}

	if !cached {
		moderationConfigUpdateCacheMut.Lock()
		moderationConfigUpdateCache[key] = cache
		moderationConfigUpdateCacheMut.Unlock()
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (q moderationConfigQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q moderationConfigQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for moderation_configs")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for moderation_configs")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o ModerationConfigSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ModerationConfigSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), moderationConfigPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"moderation_configs\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, moderationConfigPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in moderationConfig slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all moderationConfig")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *ModerationConfig) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *ModerationConfig) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models: no moderation_configs provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	nzDefaults := queries.NonZeroDefaultSet(moderationConfigColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	moderationConfigUpsertCacheMut.RLock()
	cache, cached := moderationConfigUpsertCache[key]
	moderationConfigUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			moderationConfigAllColumns,
			moderationConfigColumnsWithDefault,
			moderationConfigColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			moderationConfigAllColumns,
			moderationConfigPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert moderation_configs, could not build update column list")
		}

		ret := strmangle.SetComplement(moderationConfigAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(moderationConfigPrimaryKeyColumns) == 0 {
				return errors.New("models: unable to upsert moderation_configs, could not build conflict column list")
			}

			conflict = make([]string, len(moderationConfigPrimaryKeyColumns))
			copy(conflict, moderationConfigPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"moderation_configs\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(moderationConfigType, moderationConfigMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(moderationConfigType, moderationConfigMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert moderation_configs")
	}

	if !cached {
		moderationConfigUpsertCacheMut.Lock()
		moderationConfigUpsertCache[key] = cache
		moderationConfigUpsertCacheMut.Unlock()
	}

	return nil
}

// DeleteG deletes a single ModerationConfig record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *ModerationConfig) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single ModerationConfig record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *ModerationConfig) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no ModerationConfig provided for delete")
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), moderationConfigPrimaryKeyMapping)
	sql := "DELETE FROM \"moderation_configs\" WHERE \"guild_id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from moderation_configs")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for moderation_configs")
	}

	return rowsAff, nil
}

func (q moderationConfigQuery) DeleteAllG(ctx context.Context) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all matching rows.
func (q moderationConfigQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no moderationConfigQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from moderation_configs")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for moderation_configs")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o ModerationConfigSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ModerationConfigSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), moderationConfigPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"moderation_configs\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, moderationConfigPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from moderationConfig slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for moderation_configs")
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *ModerationConfig) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: no ModerationConfig provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *ModerationConfig) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindModerationConfig(ctx, exec, o.GuildID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ModerationConfigSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: empty ModerationConfigSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ModerationConfigSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ModerationConfigSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), moderationConfigPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"moderation_configs\".* FROM \"moderation_configs\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, moderationConfigPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ModerationConfigSlice")
	}

	*o = slice

	return nil
}

// ModerationConfigExistsG checks if the ModerationConfig row exists.
func ModerationConfigExistsG(ctx context.Context, guildID int64) (bool, error) {
	return ModerationConfigExists(ctx, boil.GetContextDB(), guildID)
}

// ModerationConfigExists checks if the ModerationConfig row exists.
func ModerationConfigExists(ctx context.Context, exec boil.ContextExecutor, guildID int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"moderation_configs\" where \"guild_id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, guildID)
	}
	row := exec.QueryRowContext(ctx, sql, guildID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if moderation_configs exists")
	}

	return exists, nil
}

// Exists checks if the ModerationConfig row exists.
func (o *ModerationConfig) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return ModerationConfigExists(ctx, exec, o.GuildID)
}
